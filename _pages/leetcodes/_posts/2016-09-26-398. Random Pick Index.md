---
layout: leetcode
title: 398. Random Pick Index
categories: [leetcode]
excerpt_separator: <!--more-->
---
My first idea was to use a global hash map to track what indices each number occurs at. This exceeded the memory limit.
We got no choice but to do it in the run: whenever a query is sent, we loop through the `nums` array and filter out those indices that have the target number. Keep those indices in a list called `candidates`, and then randomly pick one from the list as the return value.
A little optimization: We could cache the last number we were asked to pick. If the next time we are asked to pick the same number, it can save us from looping through the array again.  
Time Complexity: $$O(kn)$$ if k `pick()` operations are called.
<!--more-->

### Java Code:
{% gist 8dbbe765febad07abd84f8ea90a60b2e %}

<div
  class="fb-like"
  data-share="true"
  data-width="450"
  data-show-faces="true">
</div>
<div class="fb-comments" data-href="https://tyge318.github.io/{{page.title}}/" data-numposts="10"></div>
