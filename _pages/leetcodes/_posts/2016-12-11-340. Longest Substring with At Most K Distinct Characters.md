---
layout: leetcode
title: 340. Longest Substring with At Most K Distinct Characters
categories: [leetcode]
excerpt_separator: <!--more-->
---
Use the **sliding window** method.  
We need two variables `i` and `begin`, each marks the **end** and **begin** of the sliding window.  
Scan through each character with variable `i` and keep track of their frequency using hashmap. The size of the hashmap is the nubmer of distinct characters. Thus whenever its value is greater than $$k$$, we need to adjust the size of the sliding window (i.e. move variable `begin`) and update the character frequency of the sliding window, until a character's frequency becomes 0 and we remove it from the hashmap. (This results in the hashmap size backing to $$k$$.)  
Time Complexity: $$O(n)$$
<!--more-->

### Java Code:
{% highlight java %}
public class Solution {
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        if( s == null || s.isEmpty())
            return 0;
        if( s.length() <= k)
            return s.length();
            
        int begin = 0, ans = 0;
        Map<Character, Integer> counts = new HashMap<>();
        for(int i=0; i<s.length(); i++) {
            char c = s.charAt(i);
            if( !counts.containsKey(c) )
                counts.put(c, 1);
            else
                counts.put(c, counts.get(c)+1);
            while( counts.size() > k ) {
                char beginChar = s.charAt(begin++);
                counts.put(beginChar, counts.get(beginChar)-1);
                if( counts.get(beginChar) == 0 )
                    counts.remove(beginChar);
            }
            ans = Math.max(ans, i-begin+1);
        }
        return ans;
    }
}
{% endhighlight %}
<div
  class="fb-like"
  data-share="true"
  data-width="450"
  data-show-faces="true">
</div>
<div class="fb-comments" data-href="https://tyge318.github.io/{{page.title}}/" data-numposts="10"></div>
